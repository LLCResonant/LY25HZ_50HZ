/**********************************************************************
* File: Main_BIOS.c
* Devices: TMS320F2803x
* Author: David M. Alter, Texas Instruments Inc.
* History:
*   07/08/09 - original (D. Alter)
**********************************************************************/
#include "F28035_example.h"				// Main include file

//--- Global Variables
//Uint16 AdcBuf[ADC_BUF_LEN];				// ADC data buffer allocation
Uint16 g_u16DelayTimeSys = 0;



//--- Global functions
void SysParamDefault(); 

/**********************************************************************
* Function: main()
*
* Description: Main function for F2803x example.
**********************************************************************/
void main(void)
{
//--- CPU Initialization
	InitSysCtrl();						// Initialize the CPU
	InitPieCtrl();						// Initialize and enable the PIE
	InitWatchdog();						// Initialize the Watchdog Timer
	InitGpio();							// Initialize the shared GPIO pins
   
   
	Init_Scia(TEST_COMM_BAUDRATE, MODE_INT);
 
#ifdef EXAMPLE_FLASH					// EXAMPLE_FLASH, if defined, is in CCS project options

//--- Copy all Flash sections that need to run from RAM (use memcpy() from RTS library)

// Section secureRamFuncs contains user defined code that runs from CSM secured RAM
	memcpy(&secureRamFuncs_runstart, &secureRamFuncs_loadstart, (Uint32)&secureRamFuncs_loadsize);

//--- Initialize the Flash and OTP
	InitFlash();						// Initialize the Flash

#endif

//--- Peripheral Initialization

//    GPIO25_Xint_Init();

	AdcRegs.ADCCTL1.bit.RESET = 1;		// Reset the ADC
	// Please note that for the delay function below to operate correctly the
    // CPU_RATE define statement in the DSP2803x_Examples.h file must
    // contain the correct CPU clock period in nanoseconds.
    EALLOW;
    AdcRegs.ADCCTL1.bit.ADCBGPWD  = 1;      // Power ADC BG
    AdcRegs.ADCCTL1.bit.ADCREFPWD = 1;      // Power reference
    AdcRegs.ADCCTL1.bit.ADCPWDN   = 1;      // Power ADC
    AdcRegs.ADCCTL1.bit.ADCENABLE = 1;      // Enable ADC
    AdcRegs.ADCCTL1.bit.ADCREFSEL = 1;      // Select interal BG
    EDIS;

	AdcOffsetSelfCal();

	InitAdc();							// Initialize the ADC
	InitEPwm();							// Initialize the PWM
	InitECap();							// Initialize the Capture units
	Eeprom_Gpio_Init();
	InitHRCap();
	InitECanGpio();                     // Initialize the ECan GPIO.
	InitECan();							// Initialize the ECan.
	InitECana();						// Initialize the ECana.
    SysParamDefault(); 
	
//	ReadEnergyOutput_PowerUp();
//--- Enable interrupts
	SetDBGIER(IER | 0x6000);							// Enable everything in IER, plus TINT2 and DLOGINT
	*(volatile unsigned int *)0x00000C14 |= 0x0C00;		// Set TIMER2 FREE=SOFT=1
    // DSP/BIOS will enable global interrupts (INTM and DBGM)
} // end of main()



/**********************************************************************
* Function: UserInit()
*
* Description: This is the user initialization file to be specified in
* the DSP/BIOS configuration file, System - Global Settings.
**********************************************************************/
void UserInit(void)
{
#ifdef EXAMPLE_FLASH					// EXAMPLE_FLASH, if defined, is in CCS project options

// Section .trcdata is generated by DSP/BIOS.
// It must be copied from its load to its run address BEFORE main().
	memcpy(&trcdata_runstart, &trcdata_loadstart, (Uint32)&trcdata_loadsize);

#endif

} // end of UserInit()



/**********************************************************************
* Function: SysParamDefault(void)
*
* Description: This is the user initialization
*  - Global Settings.
**********************************************************************/

void SysParamDefault(void)
{
	Uint8 u8temp = 0;
 	SCR_Bypass_Disable();
 	SCR_INV_Disable();

	ADGain.i32VGrid = VGridMeasureGain;
	ADGain.i32TempAmb = TempAmbMeasureGain;

	SafetyReg.i32FreGrid_HiLimit = FreGridHiLimit;
	SafetyReg.i32FreGrid_LowLimit = FreGridLowLimit;
	SafetyReg.i32FreGrid_ProtectionTime = FreGridProtectionTime;

	u8temp = ProtectionSet0 + ProtectionSet1 * 2;
	if (u8temp == 0x00)
	{
		SafetyReg.i32VGrid_HiLimit = VGridHi1Limit;
		SafetyReg.i32VGrid_LowLimit = VGridLow1Limit;
	}
	else if (u8temp == 0x01)
	{
		SafetyReg.i32VGrid_HiLimit = VGridHi2Limit;
		SafetyReg.i32VGrid_LowLimit = VGridLow2Limit;
	}
	else
	{
		SafetyReg.i32VGrid_HiLimit = VGridHi2Limit;
		SafetyReg.i32VGrid_LowLimit = VGridLow2Limit;
	}

	SafetyReg.i32VGrid_HiLimitBack = SafetyReg.i32VGrid_HiLimit - _IQ(5);
	SafetyReg.i32VGrid_LowLimitBack = SafetyReg.i32VGrid_LowLimit + _IQ(5);
	
	SafetyReg.i16VGrid_ProtectionTime = VGridProtectionTime;
	SafetyReg.i32TempAmb_HiLimit = TempAmbHiLimit;
	SafetyReg.i32TempAmb_ProtectionTime = TempProtecitonTime;

	ADChannelOffset.i32VGrid = 0;
	ADChannelOffset.i32VOut = 0;
	ADChannelOffset.i32IGrid = 0;
	ADChannelOffset.i32TempAmb = 0;

	ADGain.i32VGrid = VGridMeasureGain;
	ADGain.i32VOut = VOutMeasureGain;
	ADGain.i32IGrid = IGridMeasureGain;
	ADGain.i32TempAmb = TempAmbMeasureGain;

	ADCorrection.i32VGrid = 1;
	ADCorrection.i32VOut = 1;
	ADCorrection.i32IGrid = 1;
	ADCorrection.i32TempAmb = 1;

	AD_Acc.i32TempAmb = 0;
	AD_Acc.i32VGrid_RMS = 0;
	AD_Acc.i32GridFreq = 0;
	AD_Acc.i16Counter = 0;
	AD_Acc.i32IGrid_RMS = 0;
	AD_Acc.i32VOut_RMS = 0;
	AD_Acc.i32VGrid_ave = 0;
	AD_Acc.i32VOut_ave = 0;

	AD_Sum.i32TempAmb = 0;
	AD_Sum.i32VGrid_RMS = 0;
	AD_Sum.i32GridFreq = 0;
	AD_Sum.i16Counter = 0;
	AD_Sum.i32IGrid_RMS = 0;
	AD_Sum.i32VOut_RMS = 0;
	AD_Sum.i32VGrid_ave = 0;
	AD_Sum.i32VOut_ave = 0;

	Calc_Result.i32TempAmb = 0;
	Calc_Result.i32VGrid_RMS = 0;
	Calc_Result.i32GridFreq = 0;
	Calc_Result.i16Counter = 0;
	Calc_Result.i32IGrid_RMS = 0;
	Calc_Result.i32VGrid_ave = 0;
	Calc_Result.i32VOut_RMS = 0;
	Calc_Result.i32VOut_ave = 0;

	g_SysFaultMessage.Word.byte0 = 0;
	g_SysFaultMessage.Word.byte1 = 0;

	g_StateCheck.Word.byte0 = 0;
	g_StateCheck.Word.byte1 = 0;
	g_StateCheck.bit.AD_initial  = 1;

	g_SysWarningMessage.Word.byte0 = 0;
	g_SysWarningMessage.Word.byte1 = 0;

	//ECan
	Ecan_ModuleData.BusN_Volt = 0;
	Ecan_ModuleData.BusP_Volt = 0;
	Ecan_ModuleData.Check = 0;

	Ecan_ModuleData.Error.Byte.Alert = 0;
	Ecan_ModuleData.Error.Byte.Fault1 = 0;
	Ecan_ModuleData.Error.Byte.Fault2 = 0;

	Ecan_ModuleData.Error.Byte.Fault3 = 0;
	Ecan_ModuleData.Input_Curr_Rms = 0;
	Ecan_ModuleData.Input_Volt_Rms = 0;

	Ecan_ModuleData.InvH_Cur_Rms = 0;
	Ecan_ModuleData.InvH_Freq = 0;
	Ecan_ModuleData.InvH_Temp = 0;

	Ecan_ModuleData.InvH_Volt_Rms = 0;
	Ecan_ModuleData.InvL_Cur_Rms = 0;
	Ecan_ModuleData.InvL_Freq = 0;

	Ecan_ModuleData.InvL_Temp = 0;
	Ecan_ModuleData.InvL_Volt_Rms = 0;
	Ecan_ModuleData.OutH_Volt_Rms = 0;

	Ecan_ModuleData.OutL_Volt_Rms = 0;
	Ecan_ModuleData.PFC_Temp = 0;
	Ecan_ModuleData.Phase_Lead = 0;

	Ecan_ModuleData.RunTimeHour_H = 0;
	Ecan_ModuleData.RunTimeHour_L = 0;

	 Ecan_SytemREVISED.Input_Volt_Rms = 0;
	 Ecan_SytemREVISED.Bus_P = 0;
	 Ecan_SytemREVISED.Bus_N = 0;

	 Ecan_SytemREVISED.InvH_Volt_Rms = 0;
	 Ecan_SytemREVISED.InvL_Volt_Rms = 0;
	 Ecan_SytemREVISED.InvH_Cur_Rms = 0;

	 Ecan_SytemREVISED.InvL_Cur_Rms = 0;
	 Ecan_SytemREVISED.InvH_OutV_Rms = 0;
	 Ecan_SytemREVISED.InvL_OutV_Rms = 0;

	 Ecan_SytemREVISED.PFC_Temp = 0;
	 Ecan_SytemREVISED.InvH_Temp = 0;
	 Ecan_SytemREVISED.InvL_Temp = 0;

	 Ecan_SytemREVISED.Input_Cur_Rms = 0;
	 Ecan_SytemREVISED.Aver_Curr_InvH = 0;
	 Ecan_SytemREVISED.Aver_Curr_InvL = 0;

	 Ecan_SytemREVISED.RestartOverTimes = 0;
	 Ecan_SytemREVISED.INVH_Volt_Ref = 0;
	 Ecan_SytemREVISED.INVL_Volt_Ref = 0;

	 //ECan upper computer order
	 Ecan_SytemOrder.rsvr0 = 0;
	 Ecan_SytemOrder.Defaluts = 0xFFFF;
	 Ecan_SytemOrder.Output_Enable = 0;
	 Ecan_SytemOrder.rsvr1 = 0;

	 EcanP2A_Tx.P2AMail_id.all = 0xC0000007;
	 EcanP2A_Tx.P2AMail_data.DWord.CANH_Bytes = 0x00000000;
	 EcanP2A_Tx.P2AMail_data.DWord.CANL_Bytes = 0x00000000;

	 Ecan_Error.u8Upload_Trans_Error = 0;
	 Ecan_Error.u8Broadcast_Trans_Error = 0;

	 RunningTime.Hour_H = 0;
	 RunningTime.Hour_L = 0;
	 RunningTime.Minute = 0;
	 RunningTime.Second = 0;
	 RunningTime.OverFlow = 0;
	 RunningTime.TimeCheck = 0;
}    

/**********************************************************************
* FUNCION :  SEM post  when periodic   timerBase of 2ms   is ready
* PURPOSE :  SEM post  for  state changed
* INPUT :
*        void
* RETURN :
*        void
* CALLS:
*        void
*
* CALLED BY:  DSP/BIOS kernel 2ms periodic  call 
* 
**********************************************************************/
void TimeBase2msPRD(void)
{  // static Uint16 LedPrd2msCount=0;
   SEM_post(&TimeBase2msReady);
   FanCntl();
}




/**********************************************************************
* FUNCION :  SEM post  when  periodic  timerBase of 10ms  is ready
* PURPOSE :  SEM post  for  MPPT or anti islanding detection
* INPUT :
*        void
* RETURN :
*        void
* CALLS:
*        void
*
* CALLED BY:  DSP/BIOS kernel 10ms periodic  call 
* PRD_TimeBase500ms
**********************************************************************/
void TimeBase500msPRD(void)
{
	SEM_post(&SEM_TimeBase500ms);     
} // end of TimerBase10msPRD()


/*Modified by Shen Yuan -2011.11.2*/
/**********************************************************************
* FUNCION :  
* PURPOSE :
* INPUT :
*        void
* RETURN :
*        void
* CALLS:
*        void
*
* CALLED BY:  DSP/BIOS kernel
**********************************************************************/
void TimeBase20msPRD(void)
{
	static Uint16 scia_cnt=0;

	scia_cnt++;
	if(2 == scia_cnt)
	{
		SEM_post(&SEM_SCIAComm);
		scia_cnt = 0;
		if(SciaRegs.SCICTL1.bit.SWRESET == 0)
		{
			SciaRegs.SCICTL1.bit.SWRESET = 1;
			//scib_reset ++;
		}
		/*if(scib_reset >= 100)
		{
			scib_reset = 0;
			g_SysWarningMessage.bit.LCD_Comm_Error = 1;
		}*/
	}
} // end of TimerBase20msPRD()

//--- end of file -----------------------------------------------------



